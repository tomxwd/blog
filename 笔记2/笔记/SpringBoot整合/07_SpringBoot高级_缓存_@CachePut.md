---
2019-08-01 09:33:55

---



@CachePut:

即调用方法，又更新缓存数据；

修改了数据库的某个数据，同时更新缓存；



运行时机：

1. 先调用目标方法
2. 将目标方法的结果缓存起来



测试步骤：

1. 查询1号员工：查询到的结果会放在缓存中，以后查询还是原来的结果；
2. 更新1号员工：更新【id=1&lastName=张三&email=zhangsan@qq.com&gender=1&dId=2】
3. 再次查询1号员工
   - 应该是更新后的员工。
   - 然而显示的是更新前的数据。
   - **原因很简单，因为我们放入缓存的时候是按照key-value的形式，查询一号员工的时候，key是1，而更新的时候默认将方法的返回值放入缓存中，key默认是参数，所以这时候key是传入的employee对象，值是返回的对象，所以1号员工没被更新到，由于key不同。**
   - 方案1：把更新方法的key改为用员工id，key=“#employee.id”或者key=“#result.id”
   - 注意：**@Cacheable的key不能用#result**,因为在返回之前要拿着key去缓存中找。
   - 